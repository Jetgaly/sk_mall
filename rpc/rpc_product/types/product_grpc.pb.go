// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.19.4
// source: product.proto

package __

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Product_CreateProduct_FullMethodName           = "/product.Product/CreateProduct"
	Product_CreateSKEvent_FullMethodName           = "/product.Product/CreateSKEvent"
	Product_CreateSKProduct_FullMethodName         = "/product.Product/CreateSKProduct"
	Product_GetSKProduct_FullMethodName            = "/product.Product/GetSKProduct"
	Product_GetSKEvStatusByPId_FullMethodName      = "/product.Product/GetSKEvStatusByPId"
	Product_GetSKEvStatus_FullMethodName           = "/product.Product/GetSKEvStatus"
	Product_ReduceSkProductStock_FullMethodName    = "/product.Product/ReduceSkProductStock"
	Product_ComReduceSkProductStock_FullMethodName = "/product.Product/ComReduceSkProductStock"
	Product_GetSkproductList_FullMethodName        = "/product.Product/GetSkproductList"
)

// ProductClient is the client API for Product service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProductClient interface {
	CreateProduct(ctx context.Context, in *CreateProductReq, opts ...grpc.CallOption) (*CreateProductResp, error)
	CreateSKEvent(ctx context.Context, in *CreateSKEventReq, opts ...grpc.CallOption) (*CreateSKEventResp, error)
	CreateSKProduct(ctx context.Context, in *CreateSKProductReq, opts ...grpc.CallOption) (*CreateSKProductResp, error)
	// rpc GetProduct(GetProductReq) returns(GetProductResp);
	GetSKProduct(ctx context.Context, in *GetSKProductReq, opts ...grpc.CallOption) (*GetSKProductResp, error)
	GetSKEvStatusByPId(ctx context.Context, in *GetSKEvStatusByPIdReq, opts ...grpc.CallOption) (*GetSKEvStatusByPIdResp, error)
	GetSKEvStatus(ctx context.Context, in *GetSKEvStatusReq, opts ...grpc.CallOption) (*GetSKEvStatusResp, error)
	ReduceSkProductStock(ctx context.Context, in *ReduceSkProductStockReq, opts ...grpc.CallOption) (*ReduceSkProductStockResp, error)
	ComReduceSkProductStock(ctx context.Context, in *ReduceSkProductStockReq, opts ...grpc.CallOption) (*ReduceSkProductStockResp, error)
	GetSkproductList(ctx context.Context, in *GetSkproductListReq, opts ...grpc.CallOption) (*GetSkproductListResp, error)
}

type productClient struct {
	cc grpc.ClientConnInterface
}

func NewProductClient(cc grpc.ClientConnInterface) ProductClient {
	return &productClient{cc}
}

func (c *productClient) CreateProduct(ctx context.Context, in *CreateProductReq, opts ...grpc.CallOption) (*CreateProductResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateProductResp)
	err := c.cc.Invoke(ctx, Product_CreateProduct_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productClient) CreateSKEvent(ctx context.Context, in *CreateSKEventReq, opts ...grpc.CallOption) (*CreateSKEventResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateSKEventResp)
	err := c.cc.Invoke(ctx, Product_CreateSKEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productClient) CreateSKProduct(ctx context.Context, in *CreateSKProductReq, opts ...grpc.CallOption) (*CreateSKProductResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateSKProductResp)
	err := c.cc.Invoke(ctx, Product_CreateSKProduct_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productClient) GetSKProduct(ctx context.Context, in *GetSKProductReq, opts ...grpc.CallOption) (*GetSKProductResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSKProductResp)
	err := c.cc.Invoke(ctx, Product_GetSKProduct_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productClient) GetSKEvStatusByPId(ctx context.Context, in *GetSKEvStatusByPIdReq, opts ...grpc.CallOption) (*GetSKEvStatusByPIdResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSKEvStatusByPIdResp)
	err := c.cc.Invoke(ctx, Product_GetSKEvStatusByPId_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productClient) GetSKEvStatus(ctx context.Context, in *GetSKEvStatusReq, opts ...grpc.CallOption) (*GetSKEvStatusResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSKEvStatusResp)
	err := c.cc.Invoke(ctx, Product_GetSKEvStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productClient) ReduceSkProductStock(ctx context.Context, in *ReduceSkProductStockReq, opts ...grpc.CallOption) (*ReduceSkProductStockResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReduceSkProductStockResp)
	err := c.cc.Invoke(ctx, Product_ReduceSkProductStock_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productClient) ComReduceSkProductStock(ctx context.Context, in *ReduceSkProductStockReq, opts ...grpc.CallOption) (*ReduceSkProductStockResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReduceSkProductStockResp)
	err := c.cc.Invoke(ctx, Product_ComReduceSkProductStock_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productClient) GetSkproductList(ctx context.Context, in *GetSkproductListReq, opts ...grpc.CallOption) (*GetSkproductListResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSkproductListResp)
	err := c.cc.Invoke(ctx, Product_GetSkproductList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProductServer is the server API for Product service.
// All implementations must embed UnimplementedProductServer
// for forward compatibility.
type ProductServer interface {
	CreateProduct(context.Context, *CreateProductReq) (*CreateProductResp, error)
	CreateSKEvent(context.Context, *CreateSKEventReq) (*CreateSKEventResp, error)
	CreateSKProduct(context.Context, *CreateSKProductReq) (*CreateSKProductResp, error)
	// rpc GetProduct(GetProductReq) returns(GetProductResp);
	GetSKProduct(context.Context, *GetSKProductReq) (*GetSKProductResp, error)
	GetSKEvStatusByPId(context.Context, *GetSKEvStatusByPIdReq) (*GetSKEvStatusByPIdResp, error)
	GetSKEvStatus(context.Context, *GetSKEvStatusReq) (*GetSKEvStatusResp, error)
	ReduceSkProductStock(context.Context, *ReduceSkProductStockReq) (*ReduceSkProductStockResp, error)
	ComReduceSkProductStock(context.Context, *ReduceSkProductStockReq) (*ReduceSkProductStockResp, error)
	GetSkproductList(context.Context, *GetSkproductListReq) (*GetSkproductListResp, error)
	mustEmbedUnimplementedProductServer()
}

// UnimplementedProductServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedProductServer struct{}

func (UnimplementedProductServer) CreateProduct(context.Context, *CreateProductReq) (*CreateProductResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProduct not implemented")
}
func (UnimplementedProductServer) CreateSKEvent(context.Context, *CreateSKEventReq) (*CreateSKEventResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSKEvent not implemented")
}
func (UnimplementedProductServer) CreateSKProduct(context.Context, *CreateSKProductReq) (*CreateSKProductResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSKProduct not implemented")
}
func (UnimplementedProductServer) GetSKProduct(context.Context, *GetSKProductReq) (*GetSKProductResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSKProduct not implemented")
}
func (UnimplementedProductServer) GetSKEvStatusByPId(context.Context, *GetSKEvStatusByPIdReq) (*GetSKEvStatusByPIdResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSKEvStatusByPId not implemented")
}
func (UnimplementedProductServer) GetSKEvStatus(context.Context, *GetSKEvStatusReq) (*GetSKEvStatusResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSKEvStatus not implemented")
}
func (UnimplementedProductServer) ReduceSkProductStock(context.Context, *ReduceSkProductStockReq) (*ReduceSkProductStockResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReduceSkProductStock not implemented")
}
func (UnimplementedProductServer) ComReduceSkProductStock(context.Context, *ReduceSkProductStockReq) (*ReduceSkProductStockResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ComReduceSkProductStock not implemented")
}
func (UnimplementedProductServer) GetSkproductList(context.Context, *GetSkproductListReq) (*GetSkproductListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSkproductList not implemented")
}
func (UnimplementedProductServer) mustEmbedUnimplementedProductServer() {}
func (UnimplementedProductServer) testEmbeddedByValue()                 {}

// UnsafeProductServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProductServer will
// result in compilation errors.
type UnsafeProductServer interface {
	mustEmbedUnimplementedProductServer()
}

func RegisterProductServer(s grpc.ServiceRegistrar, srv ProductServer) {
	// If the following call pancis, it indicates UnimplementedProductServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Product_ServiceDesc, srv)
}

func _Product_CreateProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProductReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServer).CreateProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Product_CreateProduct_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServer).CreateProduct(ctx, req.(*CreateProductReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Product_CreateSKEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSKEventReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServer).CreateSKEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Product_CreateSKEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServer).CreateSKEvent(ctx, req.(*CreateSKEventReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Product_CreateSKProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSKProductReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServer).CreateSKProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Product_CreateSKProduct_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServer).CreateSKProduct(ctx, req.(*CreateSKProductReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Product_GetSKProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSKProductReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServer).GetSKProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Product_GetSKProduct_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServer).GetSKProduct(ctx, req.(*GetSKProductReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Product_GetSKEvStatusByPId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSKEvStatusByPIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServer).GetSKEvStatusByPId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Product_GetSKEvStatusByPId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServer).GetSKEvStatusByPId(ctx, req.(*GetSKEvStatusByPIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Product_GetSKEvStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSKEvStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServer).GetSKEvStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Product_GetSKEvStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServer).GetSKEvStatus(ctx, req.(*GetSKEvStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Product_ReduceSkProductStock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReduceSkProductStockReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServer).ReduceSkProductStock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Product_ReduceSkProductStock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServer).ReduceSkProductStock(ctx, req.(*ReduceSkProductStockReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Product_ComReduceSkProductStock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReduceSkProductStockReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServer).ComReduceSkProductStock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Product_ComReduceSkProductStock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServer).ComReduceSkProductStock(ctx, req.(*ReduceSkProductStockReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Product_GetSkproductList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSkproductListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServer).GetSkproductList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Product_GetSkproductList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServer).GetSkproductList(ctx, req.(*GetSkproductListReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Product_ServiceDesc is the grpc.ServiceDesc for Product service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Product_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "product.Product",
	HandlerType: (*ProductServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateProduct",
			Handler:    _Product_CreateProduct_Handler,
		},
		{
			MethodName: "CreateSKEvent",
			Handler:    _Product_CreateSKEvent_Handler,
		},
		{
			MethodName: "CreateSKProduct",
			Handler:    _Product_CreateSKProduct_Handler,
		},
		{
			MethodName: "GetSKProduct",
			Handler:    _Product_GetSKProduct_Handler,
		},
		{
			MethodName: "GetSKEvStatusByPId",
			Handler:    _Product_GetSKEvStatusByPId_Handler,
		},
		{
			MethodName: "GetSKEvStatus",
			Handler:    _Product_GetSKEvStatus_Handler,
		},
		{
			MethodName: "ReduceSkProductStock",
			Handler:    _Product_ReduceSkProductStock_Handler,
		},
		{
			MethodName: "ComReduceSkProductStock",
			Handler:    _Product_ComReduceSkProductStock_Handler,
		},
		{
			MethodName: "GetSkproductList",
			Handler:    _Product_GetSkproductList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "product.proto",
}
